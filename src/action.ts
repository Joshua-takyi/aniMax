"use server";
import axios from "axios";
import { cache } from "react";

export interface MovieProps {
	mal_id: number;
	title: string;
	rating: string;
	status: string;
	genres?: { mal_id: number; name: string }[];
	images: {
		webp: {
			large_image_url: string;
		};
	};
	// ... other properties as needed
}
export interface GetMoviesParams {
	page: number;
	type: string;
	genre?: string;
	rating?: string;
	status?: string;
	order_by?: string;
}

const apiUri = "https://api.jikan.moe/v4";

const fetchWithRetry = cache(async (url: string, retries = 3, delay = 1000) => {
	try {
		// Determine if we're in a browser environment
		const isBrowser = typeof window !== "undefined";

		// Only use revalidate option on the server side
		const fetchOptions = {
			headers: {
				Accept: "application/json",
				"Content-Type": "application/json",
			},
			// Only include next.revalidate when not in browser
			...(isBrowser ? {} : { next: { revalidate: 3600 } }),
		};

		const response = await fetch(url, fetchOptions);

		if (response.status === 429 && retries > 0) {
			// ? For 429 errors, implement exponential backoff
			console.log(
				`Rate limited. Retrying in ${delay}ms... (${retries} retries left)`
			);
			await new Promise((resolve) => setTimeout(resolve, delay));
			// Double the delay for exponential backoff
			return fetchWithRetry(url, retries - 1, delay * 2);
		}

		if (!response.ok) {
			throw new Error(`Failed to fetch: ${response.status}`);
		}

		return response.json();
	} catch (error) {
		// Re-throw non-rate-limiting errors after all retries are exhausted
		throw error;
	}
});

// Replace the old fetchWithCache with our new implementation
const fetchWithCache = fetchWithRetry;

//! Fetch anime recommendations by ID
export async function GetAnimeRecommendationsById({
	animeId,
}: {
	animeId: string;
}) {
	try {
		const data = await fetchWithCache(
			`${apiUri}/anime/${animeId}/recommendations`
		);
		return { data: data.data || [] };
	} catch (error) {
		console.error("Error fetching anime recommendations:", error);
		return { data: [] };
	}
}

// Add additional export for prefetch functionality
export const prefetchRecommendations = async (animeIds: string[]) => {
	return Promise.allSettled(
		animeIds.map((id) =>
			fetchWithCache(`https://api.jikan.moe/v4/anime/${id}/recommendations`)
		)
	);
};

export async function FindBySearch({
	search,
	type,
}: {
	search: string;
	type: string;
}) {
	try {
		const encodedSearch = encodeURIComponent(search);
		const encodedType = encodeURIComponent(type);
		const res = await axios.get(
			`${apiUri}/anime?q=${encodedSearch}&type=${encodedType}`
		);
		if (res.status === 200)
			return {
				data: res.data.data || [],
				message: "search results fetched successfully",
				success: true,
			};
		throw new Error("Failed to fetch search results");
	} catch (error) {
		console.error("Error fetching search results:", error);
		return { data: [] };
	}
}

export async function GetAnimeStaffById({ animeId }: { animeId: string }) {
	try {
		const data = await fetchWithCache(`${apiUri}/anime/${animeId}/staff`);
		return { data: data.data || [] };
	} catch (error) {
		console.log("Error fetching anime staff:", error);
		return { data: [] };
	}
}

export async function GetCharactersByAnimeId({ animeId }: { animeId: string }) {
	try {
		const res = await axios.get(`${apiUri}/anime/${animeId}/characters`);
		if (res.status === 200) {
			return {
				data: res.data.data || [],
				message: "characters fetched successfully",
				success: true,
			};
		}
		throw new Error("Failed to fetch characters");
	} catch (error) {
		console.log("error fetching anime characters:", error);
		return { data: [] };
	}
}

export async function GetMovies({
	genre,
	rating,
	status,
	page,
	type,
	order_by = "popularity",
}: GetMoviesParams): Promise<{
	success: boolean;
	data: MovieProps[];
	rateLimited?: boolean;
}> {
	try {
		// * Map the rating values to match Jikan API's rating parameter - Generated by Copilot
		const ratingMapping: { [key: string]: string } = {
			g: "g",
			pg: "pg",
			r17: "r17",
			r: "r",
			rx: "rx",
		};

		// * Map the status values to match Jikan API's status parameter - Generated by Copilot
		const statusMapping: { [key: string]: string } = {
			airing: "airing",
			finished: "complete",
			upcoming: "upcoming",
		};

		// ! Build URL with query parameters for consistency with other functions
		let url = `${apiUri}/anime?page=${page}&limit=15&order_by=${order_by}&type=${type}`;

		if (rating) {
			url += `&rating=${ratingMapping[rating.toLowerCase()]}`;
		}

		if (status) {
			url += `&status=${statusMapping[status.toLowerCase()]}`;
		}

		if (genre) {
			url += `&genres=${genre}`;
		}

		// ? Use fetchWithCache with a single URL parameter as defined
		const data = await fetchWithCache(url);
		return { success: true, data: data.data };
	} catch (error) {
		// ! Enhanced error handling with rate limiting detection - Generated by Copilot
		console.error("Error fetching movies:", error);
		const errorMessage = error instanceof Error ? error.message : String(error);
		return {
			success: false,
			data: [],
			rateLimited:
				errorMessage.includes("429") || errorMessage.includes("rate"),
		};
	}
}

// get Anime by ID

export async function GetAnimeById({ id }: { id: string }) {
	try {
		const data = await fetchWithCache(`${apiUri}/anime/${id}`);
		return { success: true, data: data.data };
	} catch (error) {
		console.log("Error fetching anime by ID:", error);
		return { success: false, data: null };
	}
}

type SearchResponse = {
	success: boolean;
	data: string[] | null;
	message: string;
	rateLimited?: boolean;
};
export async function GetTelegramLinks({
	queryData,
}: {
	queryData: string;
}): Promise<SearchResponse> {
	try {
		const data = await fetchWithCache(
			`http://localhost:3000/api/search?q=${queryData}`
		);
		return {
			success: true,
			data: data.data,
			message: "links we gotten from google search api",
		};
	} catch (error) {
		console.log("Error fetching telegram links:", error);
		const errorMessage = error instanceof Error ? error.message : String(error);

		return {
			data: [],
			message: "error fetching telegram links",
			success: false,
			rateLimited:
				errorMessage.includes("429") || errorMessage.includes("rate"),
		};
	}
}

export async function GetAnimeEpisodesById({ animeId }: { animeId: string }) {
	try {
		const data = await fetchWithCache(`${apiUri}/anime/${animeId}/episodes`);
		return { data: data.data || [] };
	} catch (error) {
		console.error("Error fetching anime episodes:", error);
		return { data: [] };
	}
}
