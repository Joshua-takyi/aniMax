"use client";

import { GetAnimeById } from "@/action";
import Loader from "@/app/loading";
import AnimeSearchResults from "@/components/AnimeSearchResults";
import CharacterComponent from "@/components/charactersComponent";
import EpisodesComponent from "@/components/episdoes";
import Header from "@/components/header";
// import GenreBtns from "@/components/genre-components";
import SummaryComponent from "@/components/summaryComponent";
// import TelegramComponent from "@/components/telegramComponent";
import VideoSection from "@/components/videoSection";
import { useQuery } from "@tanstack/react-query";
import { useParams } from "next/navigation";

interface AnimeData {
	mal_id: string;
	trailer: {
		youtube_id: string;
	};
	genres: {
		mal_id: number;
		name: string;
	}[];
	titles: {
		type: string;
		title: string;
	}[];
	images: {
		webp: {
			large_image_url: string;
		};
	};
	status: string;
	episodes: number;
	type: string;
	studios: [
		{
			name: string;
		}
	];
	score: number;
	duration: string;
	aired: {
		string: string;
	};
	popularity: number;
	englishTitle: string;
	japaneseTitle: string;
	synopsis: string;
	rating: string;
	scored_by: number;
	season: string;
}

export default function ProfilePage() {
	const params = useParams();
	const id = params.id as string;

	const { data, isLoading, error } = useQuery({
		queryKey: ["AnimeById", id], // * Fixed query key for better cache identification - Generated by Copilot
		queryFn: async () => {
			// ! The data access pattern was incorrect - Generated by Copilot
			const response = await GetAnimeById({
				id: id,
			});

			// ? Check for success before accessing data - Generated by Copilot
			if (!response.success || !response.data) {
				throw new Error("Failed to fetch anime data");
			}

			// * Return the data directly without nested .data access - Generated by Copilot
			return response.data as AnimeData;
		},
		enabled: !!id, // Only run query if id exists
	});

	if (isLoading) {
		return (
			<div className="flex justify-center items-center min-h-[50vh]">
				<Loader />
			</div>
		);
	}

	if (error) {
		return (
			<div className="flex justify-center items-center min-h-[50vh]">
				<p className="text-red-500">Error loading anime data</p>
			</div>
		);
	}

	if (!data) {
		return (
			<div className="flex justify-center items-center min-h-[50vh]">
				<p className="text-gray-500">No data found</p>
			</div>
		);
	}

	// Extract Japanese and English titles
	const japaneseTitle =
		data.titles.find((title) => title.type === "Japanese")?.title ?? "";
	const englishTitle =
		data.titles.find((title) => title.type === "English")?.title ?? "";

	return (
		<main className="md:py-8 py-4 flex flex-col gap-5 ">
			<Header
				duration={data.duration}
				rating={data.rating}
				year={data.aired.string}
				title={englishTitle}
				originalTitle={japaneseTitle}
			/>
			{/* video section */}
			<VideoSection videoUrl={data.trailer.youtube_id} />
			<section>
				{/* Summary section */}
				<SummaryComponent
					genres={data.genres.map((genre) => genre.name)}
					image={data.images.webp.large_image_url}
					status={data.status}
					episodes={data.episodes}
					type={data.type}
					studios={data.studios.map((studio) => studio.name)}
					released={data.aired.string}
					rating={data.rating}
					synopsis={data.synopsis}
				/>
			</section>
			<section>
				{/* anime episodes */}
				<EpisodesComponent id={data.mal_id} />
			</section>
			<section className="md:py-12">
				{/* Character section */}
				<CharacterComponent id={data.mal_id} />
			</section>
			{/* telegram component */}
			<section>
				{/* <TelegramComponent fallbackImage={data.images.webp.large_image_url} /> */}
				<AnimeSearchResults />
			</section>
		</main>
	);
}
